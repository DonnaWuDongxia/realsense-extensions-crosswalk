// Copyright (c) 2015 Intel Corporation. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// FaceTracking API
namespace face_tracking {
  dictionary ErrorEvent {
    DOMString status;
  };

  enum TrackingModeType {
    color,
    color_depth
  };

  enum TrackingStrategyType {
    appearance_time,
    closest_farthest,
    farthest_closest,
    left_right,
    right_left
  };

  enum PixelFormat {
    RGB32,
    DEPTH
  };

  enum LandmarkType {
    NOT_NAMED,
    
    EYE_RIGHT_CENTER,
    EYE_LEFT_CENTER,
    
    EYELID_RIGHT_TOP,
    EYELID_RIGHT_BOTTOM,
    EYELID_RIGHT_RIGHT,
    EYELID_RIGHT_LEFT,
    
    EYELID_LEFT_TOP,
    EYELID_LEFT_BOTTOM,
    EYELID_LEFT_RIGHT,
    EYELID_LEFT_LEFT,
    
    EYEBROW_RIGHT_CENTER,
    EYEBROW_RIGHT_RIGHT,
    EYEBROW_RIGHT_LEFT,
    
    EYEBROW_LEFT_CENTER,
    EYEBROW_LEFT_RIGHT,
    EYEBROW_LEFT_LEFT,
    
    NOSE_TIP,
    NOSE_TOP,
    NOSE_BOTTOM,
    NOSE_RIGHT,
    NOSE_LEFT,
    
    LIP_RIGHT,
    LIP_LEFT,
    
    UPPER_LIP_CENTER,
    UPPER_LIP_RIGHT,
    UPPER_LIP_LEFT,
    
    LOWER_LIP_CENTER,
    LOWER_LIP_RIGHT,
    LOWER_LIP_LEFT,
    
    FACE_BORDER_TOP_RIGHT,
    FACE_BORDER_TOP_LEFT,
    
    CHIN
  };

  dictionary FaceConfiguration {
    boolean? enableDetection;
    boolean? enableLandmarks;
    long? maxFaces;
    TrackingModeType? mode;
    TrackingStrategyType? strategy;
  };

  dictionary Image {
    PixelFormat format;
    long width;
    long height;
    ArrayBuffer data;
  };

  dictionary Rect {
    long x;
    long y;
    long w;
    long h;
  };

  dictionary Point3DFloat {
    double x;
    double y;
    double z;
  };

  dictionary Point2DFloat {
    double x;
    double y;
  };

  // DetectionData
  dictionary Detection {
    Rect boundingRect; 
    double avgDepth;
  };

  // LandmarkPoint
  dictionary LandmarkPoint {
    LandmarkType type;
    long confidenceImage;
    long confidenceWorld;
    Point3DFloat coordinateWorld;
    Point2DFloat coordinateImage;
  };

  // LandmarksData
  dictionary Landmark {
    LandmarkPoint[] points;
  };

  // Single Face Data
  dictionary FaceData {
    Detection? detection;
    Landmark? landmark;
  };

  dictionary ProcessedSample {
    Image color;
    Image? depth;
    FaceData[] faces;
  };

  callback ProcessedSamplePromise = void (ProcessedSample sample, DOMString error);
  callback Promise = void (DOMString success, DOMString error);

  interface Events {
    static void onerror();
    static void onprocessedsample();
  };

  interface Functions {
    static void start(optional FaceConfiguration config, Promise promise);
    static void stop(Promise promise);
    static void getProcessedSample(ProcessedSamplePromise promise);

    [nodoc] static FaceTracking faceTrackingConstructor(DOMString objectId);
  };
};
